1 API GATEWAY
Let’s imagine you are building an online store that uses the Microservice architecture pattern. You need to develop 2 versions:
1. HTML5/JavaScript-based UI for desktop and mobile browsers - HTML is generated by a server-side web application
2. Native Android and iPhone clients - these clients interact with the server via REST APIs
3. The online store must also expose product details via a REST API for use by 3rd party applications.
The UI would require multiple service to serve the user - Product Info, Pricing, Order, etc. Ex - The code that displays the product details needs to fetch information from all of these services.

Problem:
How do the clients of a Microservices-based application access the individual services?
Forces:
1. The granularity of APIs provided by microservices is often different than what a client needs. Microservices typically provide fine-grained APIs, which means that clients need to interact with multiple services
2. Different clients need different data
3. Network performance is different for different types of clients. Some types of clients can make more requests to backend while other's can't
4. The number of service instances and their locations (host+port) changes dynamically
5. Partitioning into services can change over time and should be hidden from clients
6. Services might use a diverse set of protocols, some of which might not be web friendly

Solution:
Implement an API gateway that is the single entry point for all clients. The API gateway handles requests in one of two ways. Some requests are simply proxied/routed to the appropriate service. It handles other requests by fanning out to multiple services. Rather than provide a one-size-fits-all style API, the API gateway can expose a different API for each client. The API gateway might also implement security, e.g. verify that the client is authorized to perform the request. (Orchestration is one feature of an API gateway).

2 BACKENDS FOR FRONTENDS
A variation of above more genetic pattern is the Backends for frontends pattern. It defines a separate API gateway for each kind of client. Example of clients - web application, mobile application, and external 3rd party application. There are three different API gateways. Each one is provides an API for its client.

Benefits:
1. Insulates the clients from how the application is partitioned into microservices
2. Insulates the clients from the problem of determining the locations of service instances
3. Provides the optimal API for each client
4. Reduces the number of requests/roundtrips
5. Simplifies the client by moving logic for calling multiple services from the client to API gateway
6. Translates from a “standard” public web-friendly API protocol to whatever protocols are used internally

Drawbacks:
1. Increased complexity - the API gateway is yet another moving part that must be developed, deployed and managed
2. Increased response time due to the additional network hop through the API gateway

Issues:
How implement the API gateway? An event-driven/reactive approach is best if it must scale to handle high loads. On the JVM, NIO-based libraries such as Netty, Spring Reactor, etc. make sense. NodeJS is another option.
